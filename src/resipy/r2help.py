#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed May 30 16:46:04 2018

@author: jkl
"""

r2help = {
'flux_type': "<p>Define the flux type to be used (either 2D or 3D)</p>",
'res_matrix' : "<p><code>res_matrix</code> is 1 if a 'sensitivity' matrix is required for the converged solution. This matrix is not the Jacobian but is the diagonal of [J^T.W^T.W.J] which gives an idea of the mesh sensitivity (see equation 5.20 of Binley and Kemna, 2005)</p><p>Set <code>res_matrix</code> to 2 if the true resolution matrix is computed for a converged solution and the diagonal is stored (see equation 5.18 of Binley and Kemna,  2005), note that this calculation is more time consuming than the ‘sensitivity matrix’ option.</p><p>Set <code>res_matrix</code> to 3 if the sensitivity map is required and an out put of the jacobian matrix and roughness matrix.</p><p>If neither sensitivity map or resolution matrix is required then set <code>res_matrix</code> to 0.</p>",
'singular_type' : "<p>Note that singularity removal can only be applied is (a) the boundaries are infinite and (b) the y=0 plane defines the upper boundary. </p>",
'inverse_type' : "<p>where <code>inverse_type</code> is 0 for pseudo-Marquardt solution or 1 for regularised solution with linear filter (usual mode) or 2 for regularised type with quadratic filter or 3 for qualitative solution or 4 for blocked linear regularised type. Note that the blocking defined here is only for a quadrilateral mesh – for blocking within a triangular mesh see the details for preparing <code>mesh.dat</code></p>",
'target_decrease': "<p><code>target_decrease</code> is a real number which allows the user to specify the relative reduction of misfit in each iteration. A value of 0.25 will mean that R2 will aim to drop the misfit by 25% (and no more) of the value at the start of the iteration. This allows a slower progression of the inversion, which can often result in a better convergence. If you set <code>target_decrease</code> to 0.0 then R2 will try to achieve the maximum reduction in misfit in the iteration.</p> ",
'qual_code' : "<p>where <code>qual_ratio</code> is 0 for qualitative comparison with forward solution, i.e. only when one observed data set is available, or <code>qual_ratio</code> is 1 if the observed data in protocol.dat contains a ratio of two datasets.</p>",
'rho_max' : "<p>where <code>rho_min</code> and <code>rho_max</code> are the minimum and maximum observed apparent resistivity to be used.</p>",
'scale' : "<p>where <code>scale</code> is a scaling factor for the mesh coordinates. This is usually 1.0 but if astandardised mesh is used, say for a unit circle, then this scaling factor is useful to adjust themesh for a specific problem. Set <code>scale</code>=1 if you do not wish to change the coordinates of themesh defined in <code>mesh.dat</code></p>",
'num_regions' : "<p>where <code>num_regions</code> is number of resistivity regions that will be specified either as starting condition for inverse solution or actual model for forward solution. The term “region” has no significance inthe inversion – it is just a means of inputting a non-uniform resistivity as a starting model for inversion or for forward calculation.</p>",
'patch' : "<p>where <code>patch_size_x</code> and <code>patch_size_y</code> are the parameter block sizes in the x and y direction, respectively. Note that the number of elements in the x direction must be perfectly divisible by <code>patch_size_x</code> and the number of elements in the y direction must be perfectly divisible by <code>patch_size_y</code> otherwise set them both to zero. </p>",
'data_type' : "<p>where <code>data_type</code> is 0 for true data based inversion or 1 for log data based. Note that the latter should improve convergence but may not work for internal electrodes (e.g. borehole type) where the polarity can change due to resistivity distributions</p>",
'reg_mode' : "<p><code>reg_mode</code> is 0 for normal regularisation; or 1 if you want to include regularisation relative to your starting resistivity (this is whatever you have set in input lines 11 to 13); or 2 if you wish to regularise relative to a previous dataset using the “Difference inversion” of LaBrecque and Yang (2000). If you select <code>reg_mode</code>=1 then Line 22 will require a regularisation parameter alpha_s. If you select <code>reg_mode</code>=2 then protocol.dat must contain an extra column (see below) with the reference dataset. In addition, your starting model (see Line 12) should be the inverse model for this reference dataset (i.e. you need to invert the reference dataset before running the time-lapse inversion). Also note that if you select <code>reg_mode</code>=2 then <code>data_type</code> is automatically set to 0 irrespective of what was entered in Line 21.</p>",
'tolerance' : "<p>where <code>tolerance</code> is desired misfit (usually 1.0)</p>",
'max_iterations' : "<p><code>max_iterations</code> is the maximum number of iterations.</p>",
'error_mod' : "<p><code>error_mod</code> is 0 if you wish to preserve the data weights, 1 or 2 if you wish the inversion to update the weights as the inversion progresses based on how good a fit each data point makes. <code>error_mod</code>=2 is recommended – this is a routine based on Morelli and LaBrecque (1996). Note that no weights will be increased.</p>",
'alpha_aniso' : "<p>The smoothing factor used in the code (alpha) is searched for at each iteration. The search is done over a range of steps in alpha, the number of steps is <code>num_alpha_steps</code>. <code>alpha_aniso</code> is the anisotropy of the smoothing factor, set <code>alpha_aniso</code> > 1 for smoother horizontal models, <code>alpha_aniso</code> < 1 for smoother vertical models, or <code>alpha_aniso</code>=1 for normal (isotropic) regularisation.</p>",
#'alpha_s' : "<p><code>alpha_s</code> is the regularisation to the starting model (if you set <code>reg_mode</code> = 1 in Line 21). Set <code>alpha_s</code> to a high value (e.g. 10) to highly penalise any departure from this starting model. Note that <code>alpha_s</code> will stay fixed – if you set it too high then R2 may not converge. R2.out will report the value of alpha used to regularise smoothing within the image – the regularisation relative to a reference model is additional to this. The user may find setting <code>alpha_s</code> useful as a comparison of inversions from two runs with difference reference models allows an assessment of the depth of investigation following the approach of Oldenburg and Li (1999).</p>",
'errorParam' : "<p>For DC, see below, for IP, see down below</p>\
                <p>It is advisable to estimate <code>a_wgt</code> and <code>b_wgt</code> from error checks in the field data (ideally from reciprocal measurements - not measures of repeatability). Typically for surface data <code>a_wgt</code> will be about 0.01 ohms and <code>b_wgt</code> will be about 0.02 (roughly equivalent to 2% error). Note that if you select data_type=1 in Line 21 then although the resistance data are transformed into log apparent conductivities the <code>a_wgt</code> and <code>b_wgt</code> parameters should still reflect the variance of the resistance; <code>rho_min</code> and <code>rho_max</code> are the minimum and maximum observed apparent resistivity to be used for inversion (use large extremes if you want all data to be used). If data are ignored by R2 because of the apparent resistivity limits then these will be reported individually in R2.log. NOTE: that the apparent resistivity calculations assume that you have set the ground surface to Y=0 and that the ground surface is flat. Note also that you can select to include individual errors for each measurement in the data input file protocol.dat – to do this <code>a_wgt</code> and <code>b_wgt</code> should be set to 0.0 – protocol.dat will then require an additional column (see later). \</p>\
                <p>where <code>min_error</code> is the minimum magnitude error (this is to ensure that very low errors are not assigned and is only used if <code>a_wgt</code> and <code>b_wgt</code> are both zero), <code>a_wgt</code> and <code>b_wgt</code> are error variance model parameters: <code>a_wgt</code> is the relative error of magnitudes; <code>b_wgt</code> is absolute error of phase values (in mrad); rho_min and rho_max are the minimum and maximum observed apparent resistivity magnitude to be used for inversion (use large extremes if you want all data to be used). <emph>NOTE that if your mesh contains topography, or the surface elevation is not zero, or the left, right and lower extent of the mesh does not represent infinite boundaries then the geometric factor computed in the code will be incorrect and thus any comparison of apparent resistivities against upper and lower limits will be invalid.</emph> For such a case you should set rho_min and rho_max to be very low and very high values, e.g. -10e10 and 10e10, respectively. Note also that you can select to include individual errors for each measurement in the data input file protocol.dat – to do this <code>a_wgt</code> and <code>b_wgt</code> should be set to 0.0. If <code>a_wgt</code> and <code>b_wgt</code> are set to zero then protocol.dat must contain errors for the data weights (see next section). It is advisable to estimate <code>a_wgt</code> and <code>b_wgt</code> from error checks in the field data (ideally from reciprocal measurements - not measures of repeatability). Typically for surface data <code>a_wgt</code> will be about 0.02 (equivalent to 2% error), <code>b_wgt</code> will be typically 2 mrad for good data, but could be much higher.</p>",
'num_xy_poly' : "<p>where <code>num_xy_poly</code> is the number of x,y co-ordinates that define a polyline bounding the output volume. If <code>num_xy_poly</code> is set to zero then no bounding is done in the x-y plane. The co-ordinates of the bounding polyline follow in the next line. NOTE: the first and last pair of co-ordinates must be identical (to complete the polyline). So, for example, if you define a bounding square in x,y then you must have 5 co-ordinates on the polyline. The polyline must be defined as a series of co-ordinates in sequence, although the order can be clockwise or anti-clockwise (see examples later). NOTE: R2 stores the vertical co-ordinates for nodes in a quadrilateral mesh with a convention positive upwards. For example, if the ground surface has an elevation of 0m and you wish to output to a depth of 8m then y=-8m must be used for the lower boundary of the polygon. Similarly, if the ground surface elevation is 100m and you wish to output to a depth of 8m then y=-92m must be used for the lower boundary of the polygon. This was not the convention for v2.7a and so any input files created for that version must be changed (this only applies to line 26). If a triangular mesh is used then the co-ordinates specified in the mesh file are used and the above comments about sign convention do not apply. </p>",
'modErr' : "<p>Compute modelling error due to the mesh by doing a forward modelling with a homogeneous resistivity of 100 Ohm.m</p>",
'parallel' : "<p>Run inversions in parallel according to the number of cores "
              "of your computer. Note that you won't be able to see the "
              "progress of the inversion or kill it while it's running. Don't "
              "do this for 3D surveys as the required memory might be huge.</p>",
'no_improve' : "<p> <code>no_improve</code> is termination criteria such that"
                " if during two iterations the misfit doesn\'t change by "
                "<code>no_improve</code> (%) then the inverse solution is stopped</p>",
'inv_type3D' : "<p> 0 for normal regularisation; 1 for background regularisation (see"
                "equation (13)); 2 for difference regularisation (see equation (7)). Note that option 2 is not"
                "a difference inversion (as per LaBrecque and Yang, 2001) but can be used for this purpose"
                "with a modification to the data in protocol.dat as shown in equation (11)</p>",
'alpha_s' : "<p><code>alpha_s</code> is an additional penalty factor applied to the starting resistivity"
            "model. If <code>alpha_s</code> is 1.0 then the regularisation applies the same"
            "weight to smoothing the model as to constraining to the background model. A smaller"
            "(no zero) value of <code>alpha_s</code> will retain some constraint to the background model.</p>",
'cginv_tolerance' : "<p><code>cginv_tolerance</code> is the tolerance (typically 0.0001) for the conjugate gradient "
                    "solution of the inverse equations</p>",
'cginv_maxits' : "<p><code>cginv_maxits</code> is the maximum number of iterations for"
                "the conjugate gradient solution of the inverse problem (this could be set to a high value < "
                "number of parameters or could be set low, say 50, to gain an approximate solution). A "
                "value of 500 for <code>cginv_maxits</code> will achieve a satisfactory solution for most problems, "
                "however, setting the value to 50 will lead to a faster execution.</p>",
'alpha_max' : "<p>The regularisation (or smoothing) parameter, alpha, is optimised each iteration by carrying "
                "out a line search. <code>alpha_max</code> is maximum starting value of reqularised scalar and "
                "<code>num_alpha_steps</code> (usually 10) is the number of alpha values used each iteration to search "
                "for the optimum alpha. Set alpha_max to a large number (say 10e10) if you do not wish to "
                "limit the maximum value of alpha. If you wish to specify a minimum value for the starting "
                "alpha then set <code>alpha_max</code> to a negative value of the minimum starting value. For example, "
                "setting <code>alpha_max</code> to -20 will mean that the starting value of alpha is at least 20. An "
                "alternative solution approach is to use one alpha at each of the inverse iterations, i.e. there "
                "is no line search for an optimum at each iteration. This can help result in a smoother final "
                "model. If <code>num_alpha_steps</code> is set to 1 then <code>alpha_max</code> is the starting value of alpha. This "
                "value is then used in subsequent iterations unless the total objective function does not drop "
                "by 5% in a subsequent iteration, or if the data misfit increases. If this happens then alpha "
                "is reduced by 50% in the following iteration. If this approach is taken then it is advisable "
                "to set <code>max_iterations</code> to at least 20.</p>",
'min_step' : "<p><code>min_step</code> is the minimum step length for attempting to improve solution. This is "
            "usually set to 0.001 to 0.01.</p>",
'notCropping' : '<p>If checked, this will prevent the mesh to be cropped to the region of interest after inversion.'
    }

